#!/bin/bash

black="$(tput setaf 0)"
red="$(tput setaf 1)"
green="$(tput setaf 2)"
yellow="$(tput setaf 3)"
blue="$(tput setaf 4)"
magenta="$(tput setaf 5)"
cyan="$(tput setaf 6)"
white="$(tput setaf 7)"


validate_set () {
  local paramname=$1
  local paramvalue=$2
  local regex=$3
  local default=$4


  if [ $# != 4 ]; then
    echo "${red}Error, validate_set usage: validate_set <VARNAME> <value> <regex> <default>" 1>&2
    echo "<value> and <default> may be empty strings but cannot be nothing;" 1>&2
    echo "<default> will only be used if <value> is an empty string" 1>&2
    echo "# set SOME_INT to 3" 1>&2
    echo "validate_set SOME_INT 3 '^[[:digit:]+]$' ''" 1>&2
    echo "# set SOME_INT to the value of \$INPUT, checking against the regex, with a default of 0 if \$INPUT isn't set or is set to '':" 1>&2
    echo "# (note that if the regex doesn't match it will error no matter what, so this will only use the default if \$INPUT isn't set or is empty AND the regex matches '')" 1>&2
    echo "validate_set SOME_INT \"\$INPUT\" '^([[:digit:]+])?$' 0" 1>&2
    echo "got: '$@' ${white}" 1>&2
    exit 1
  fi

  if [ "${paramvalue}" != "" ]; then
    if $(echo ${paramvalue} | grep -Eq "${regex}"); then
      eval "${paramname}=\"${paramvalue}\""
    else
      echo "${red}Error, '${paramname}' value '${paramvalue}' does not match regex \"${regex}\". Exiting.${white}" 1>&2
      exit 1
    fi
  else
    if $(echo ${default} | grep -Eq "${regex}"); then
      eval "${paramname}=\"${default}\""
    else
      echo "${red}Error, \"${paramname}\" default value \"${default}\" does not match regex \"${regex}\". Exiting.${white}" 1>&2
      exit 1
    fi
  fi

}

# https://unix.stackexchange.com/questions/6463/find-searching-in-parent-directories-instead-of-subdirectories
# usage location=$(find-up somefilename)
find-up () {
  curpath=$(pwd)
  while [[ "$curpath" != "" && ! -e "$curpath/$1" ]]; do
    curpath=${curpath%/*}
  done
  echo "$curpath"
}

md5sum-dir () {
  if [ $# != 1 ]; then
    echo "Usage: md5sum-dir <path>" 1>&2
  fi
  find $1 -exec md5sum {} \; 2>/dev/null | awk '{print $1}' | sort | md5sum | awk '{print $1}'
}

safe-delete-namespace () {
  if [ $# != 2 ]; then
    echo "Usage: safe-delete-namespace kube-context namespace" 1>&2
  fi

  local KUBE_CONTEXT=$1
  local NAMESPACE=$2

  kubectl config use-context $KUBE_CONTEXT

  echo "${yellow}Trying to delete namespace, checking if empty... ${white}"
  result=$(kubectl get all --namespace $NAMESPACE)
  if [ ! -z "$result" ]; then
    echo "${yellow}Warning: Not removing namespace $NAMESPACE, resources still exist:\n\n$result" 1>&2
    exit 1
  fi

  kubectl delete namespace $NAMESPACE
}



create-dir-structure () {
  if [ $# != 1 ]; then
    echo "Usage: create-dir-structure <structure.txt>" 1>&2
    echo "Where <structure.txt> describes how a directory/file structure should be created (tab-seperated), e.g." 1>&2
    echo "Relative and absolute paths can be used for source and dest; everything is done recursive; mkdir has special meaning" 1>&2
    echo "The last field indicates whether the operation should be done 'always' or only if the existing version is not present. " 1>&2
    echo "This allows for changes in files to be not overwritten if present." 1>&2
    echo "Similarly, permsonly can be used to always reset user:group and mode, but leave contents if present." 1>&2
    echo "" 1>&2
    echo "root  root  0755  mkdir  always  ./home" 1>&2
    echo "smithj  everyone  0755  mkdir  always  /home/smithj/docs" 1>&2
    echo "smithj  everyone  0755  templates/README.txt  ifnotpresent  /home/smithj/docs/README.txt" 1>&2
    echo "" 1>&2
    echo "Environment variables can be present for interpolation:" 1>&2
    echo "\$USERNAME  \$GROUPNAME  0755  templates/README.txt  permsonly  /home/\$USERNAME/docs/README.txt" 1>&2
    echo "" 1>&2
    exit 1
  fi

  while read -r user group mode source replace dest ; do
    local rUSER=$(eval echo $user)
    local rGROUP=$(eval echo $group)
    local rMODE=$(eval echo $mode)
    local rSOURCE=$(eval echo $source)
    local rDEST=$(eval echo $dest)
    local rREPLACE=$(eval echo $replace)

    if [ -e $rDEST ] && [ "$rREPLACE" == "ifnotpresent" ]; then
      echo "${yellow}Skipping $rDEST which already exists with ifnotpresent rule. ${white}"
    elif [ -e $rDEST ] && [ "$rREPLACE" == "permsonly" ]; then
      echo "${yellow}Changing ownership and permissions only $rDEST which already exists with permsonly rule. ${white}"
      chown -R $rUSER:$rGROUP $rDEST
      chmod -R $rMODE $rDEST
    elif [ "$rREPLACE" == "ifnotpresent" ] || [ "$rREPLACE" == "always" ]; then
      if [ "$rSOURCE" == "mkdir" ]; then
	echo "${yellow}(Re)Creating directory $rDEST ${white}"
        mkdir -p $rDEST
      else
	echo "${yellow}Copying $rSOURCE to $rDEST ${white}"
        dir=$(dirname $rDEST)
        mkdir -p $dir
        cp -r $rSOURCE $rDEST
      fi

      echo "${yellow}Setting owner/permissions to $rUSER:$rGROUP $rMODE on $rDEST ${white}"
      chown -R $rUSER:$rGROUP $rDEST
      chmod -R $rMODE $rDEST
    fi
 
  echo ""   

 done < $1
}

