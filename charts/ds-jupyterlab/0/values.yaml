jupyterhub:
  auth:
    type: dummy
    dummy:
      password: 
  
  scheduling:
    userScheduler:
      enabled: true
    userPods:
      nodeAffinity:
        matchNodePurpose: require
    podPriority:
      enabled: true
      globalDefault: false
      defaultPriority: 0
      userPlaceholderPriority: -10
    corePods:
      nodeAffinity:
        matchNodePurpose: require
    userPlaceholder:
      enabled: true
      replicas: 5

  cull:
    enabled: true
    timeout: 3600    # cull inactive servers after this long
    every: 600       # how often to check 
    maxAge: 0        # cull servers this old, even if active (0 disables)

  proxy:
    # TODO: don't hard code this; either generate psuedo-randomly, or ask user for salt and generate
    secretToken: "78767972dd3d0db5a98fb56554f4484daa57bc35bd73dc61aafebed8ac9fe3df"
    service: 
      type: ClusterIP
    https:
      enabled: true
      type: offload
  singleuser:
    # looks like these should be set null to delete the key (including those defaulted in the jupyterhub chart) for the c.Spawner limits below to be used
    memory:
      limit: null
      guarantee: null
    cpu:
      limit: null
      guarantee: null
    image:
      name: oneilsh/ktesting-datascience-notebook
      tag: latest
      pullPolicy: Always
    defaultUrl: "/lab"
    cmd: ["start-singleuser.sh", "--allow-root"]  # don't think I need to add --allow-root... 
    storage:
      type: none
      extraVolumes:
        - name: various-volume
          configMap:
            name: various-configmap
        - name: start-volume
          configMap:
            name: start-configmap
      extraVolumeMounts:
        - name: start-volume
          mountPath: /usr/local/bin/start.sh
          subPath: start.sh
        - name: various-volume
          mountPath: /usr/local/bin/various

    extraEnv:
      NFS_HOME_SVC: ""
    uid: 0
    fsGid: 0

  ingress:
    enabled: true
    annotations:
      kubernetes.io/ingress.class: "nginx"
      nginx.org/mergeable-ingress-type: "minion"
      nginx.org/websocket-services: "proxy-public"
    hosts:
    - eksdevd.dsosu.us 
    tls:
    - hosts:
      - eksdevd.dsosu.us

  hub:
    baseUrl: /
    db:
      upgrade: false 
    image:
      name: oneilsh/ktesting-k8s-hub
      tag: 'latest'   # installed nativeauthenticator: https://blog.jupyter.org/simpler-authentication-for-small-scale-jupyterhubs-with-nativeauthenticator-999534c77a09
    extraVolumes:
      - name: hubfiles-volume
        configMap:
          name: hubfiles-configmap
    extraVolumeMounts:
      - name: hubfiles-volume
        mountPath: /etc/jupyter/hubfiles


    extraConfig:
      # we pass in mem and cpu requests via environment variables because the rancher UI won't pass them as floats :/  
      #resources: |
      #  import os
      #  # maybe the order of these matters? gaurantee first?
      #  if os.environ["MEMORY_GUARANTEE"]:
      #    c.Spawner.mem_guarantee = str(os.environ["MEMORY_GUARANTEE"]) + "G"
      #  if os.environ["MEMORY_LIMIT"]:
      #    c.Spawner.mem_limit = str(os.environ["MEMORY_LIMIT"]) + "G"
      #  if os.environ["CPU_GUARANTEE"]:
      #    c.Spawner.cpu_guarantee = float(os.environ["CPU_GUARANTEE"])
      #  if os.environ["CPU_LIMIT"]:
      #    c.Spawner.cpu_limit = float(os.environ["CPU_LIMIT"])
      nfspriv: |
        from kubernetes import client
        def modify_pod_hook(spawner, pod):
            pod.spec.containers[0].security_context = client.V1SecurityContext(
                privileged=True,
                capabilities=client.V1Capabilities(
                    add=['SYS_ADMIN']
                )
            )
            return pod
        c.KubeSpawner.modify_pod_hook = modify_pod_hook

      authsetting: |
        import os

        env_auth_type = os.environ["AUTH_TYPE"]
        
        if env_auth_type == "native":
          from nativeauthenticator import NativeAuthenticator
          from tornado import gen

          class NativeExtraAuthenticator(NativeAuthenticator):
            @gen.coroutine
            def pre_spawn_start(self, user, spawner):
              # for use by scripts in start-notebook.d
              # NB_USER is the username logged in with
              # ADMIN_USER is "True" if they're an admin, "False" otherwise
              spawner.environment['NB_USER'] = user.name
              spawner.environment['ADMIN_USER'] = str(user.admin)
              # below for debugging
              #spawner.environment['NB_UID'] = "1000"
              #spawner.environment['GRANT_SUDO'] = "yes"
       
          ## read admin user list from provided values 
          c.JupyterHub.authenticator_class = NativeExtraAuthenticator
          # location in docker image
          c.JupyterHub.template_paths = ["/home/jovyan/nativeauthenticator/nativeauthenticator/templates/"]       
        
        elif env_auth_type == "saml":
          from samlauthenticator import SAMLAuthenticator
          from tornado import gen

          class SAMLExtraAuthenticator(SAMLAuthenticator):
            @gen.coroutine
            def pre_spawn_start(self, user, spawner):
              spawner.environment['NB_USER'] = user.name
              spawner.environment['ADMIN_USER'] = str(user.admin)

          # SAML config with help from Andrew Morgan in IAM at OSU - thanks Andy :)
          SAMLExtraAuthenticator.time_format_string = '%Y-%m-%dT%H:%M:%S.%fZ'
          
          jupyterhub_host = os.environ['JUPYTERHUB_HOST']
          hub_prefix = os.environ['JUPYTERHUB_BASE_URL']
          jupyterhub_url = "https://" + jupyterhub_host + hub_prefix # hub_prefix should begin and end in /

          SAMLExtraAuthenticator.entity_id = jupyterhub_url
          SAMLExtraAuthenticator.acs_endpoint_url = jupyterhub_url + "hub/login"
          
          # Don't use SAML Single Log Out
          # Yes, there is a typo in this variable name "forwad"
          SAMLAuthenticator.slo_forwad_on_logout = False

          SAMLExtraAuthenticator.metadata_filepath = "/etc/jupyter/hubfiles/idp-dev-metadata.xml"
          SAMLExtraAuthenticator.xpath_username_location = '/samlp:Response/saml:Assertion/saml:AttributeStatement/saml:Attribute[@Name="urn:oid:0.9.2342.19200300.100.1.1"]/saml:AttributeValue/text()' 
          # this and entity_id will likely need to be set based on the ingress path, which will likely need to come in as an environment variable
          #SAMLExtraAuthenticator.acs_endpoint_url = '' # protocol::/host/prefix/hub/local 
          c.JupyterHub.authenticator_class = SAMLExtraAuthenticator
        
        else:
          from jupyterhub.auth import DummyAuthenticator
          from tornado import gen

          class DummyExtraAuthenticator(DummyAuthenticator):
            @gen.coroutine
            def pre_spawn_start(self, user, spawner):
              spawner.environment['NB_USER'] = user.name
              spawner.environment['ADMIN_USER'] = str(user.admin)
       
          ## read admin user list from provided values 
          c.JupyterHub.authenticator_class = DummyExtraAuthenticator

        admin_users_comma_sep = os.environ["ADMIN_USERS"]  # grab admin usernames from environment variable set in questions.yaml
        admin_users = set([entry.strip() for entry in admin_users_comma_sep.split(",")]) # split it into a set to use
        c.Authenticator.admin_users = admin_users
        c.JupyterHub.admin_access = True

